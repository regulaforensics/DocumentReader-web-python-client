# coding: utf-8

"""
    Generated by: https://openapi-generator.tech
"""

from __future__ import annotations
import json
import pprint
from pydantic import BaseModel, ConfigDict, Field, StrictStr, ValidationError, field_validator
from typing import Any, List, Optional
from regula.documentreader.webclient.gen.models.authenticity_result import AuthenticityResult
from regula.documentreader.webclient.gen.models.byte_array_result import ByteArrayResult
from regula.documentreader.webclient.gen.models.chosen_document_type_result import ChosenDocumentTypeResult
from regula.documentreader.webclient.gen.models.doc_bar_code_info import DocBarCodeInfo
from regula.documentreader.webclient.gen.models.document_binary_info_result import DocumentBinaryInfoResult
from regula.documentreader.webclient.gen.models.document_image_result import DocumentImageResult
from regula.documentreader.webclient.gen.models.document_position_result import DocumentPositionResult
from regula.documentreader.webclient.gen.models.document_types_candidates_result import DocumentTypesCandidatesResult
from regula.documentreader.webclient.gen.models.encrypted_rcl_result import EncryptedRCLResult
from regula.documentreader.webclient.gen.models.face_detection_result import FaceDetectionResult
from regula.documentreader.webclient.gen.models.graphics_result import GraphicsResult
from regula.documentreader.webclient.gen.models.image_quality_result import ImageQualityResult
from regula.documentreader.webclient.gen.models.images_result import ImagesResult
from regula.documentreader.webclient.gen.models.lexical_analysis_result import LexicalAnalysisResult
from regula.documentreader.webclient.gen.models.license_result import LicenseResult
from regula.documentreader.webclient.gen.models.mrz_detector_result import MRZDetectorResult
from regula.documentreader.webclient.gen.models.mrz_position_result import MRZPositionResult
from regula.documentreader.webclient.gen.models.mrz_test_quality_result import MRZTestQualityResult
from regula.documentreader.webclient.gen.models.rfid_graphics_info_result import RFIDGraphicsInfoResult
from regula.documentreader.webclient.gen.models.rfid_text_data_result import RFIDTextDataResult
from regula.documentreader.webclient.gen.models.status_result import StatusResult
from regula.documentreader.webclient.gen.models.text_data_result import TextDataResult
from regula.documentreader.webclient.gen.models.text_result import TextResult
from pydantic import StrictStr, Field
from typing import Union, List, Set, Optional, Dict
from typing_extensions import Literal, Self

CONTAINERLISTLISTINNER_ONE_OF_SCHEMAS = ["AuthenticityResult", "ByteArrayResult", "ChosenDocumentTypeResult", "DocBarCodeInfo", "DocumentBinaryInfoResult", "DocumentImageResult", "DocumentPositionResult", "DocumentTypesCandidatesResult", "EncryptedRCLResult", "FaceDetectionResult", "GraphicsResult", "ImageQualityResult", "ImagesResult", "LexicalAnalysisResult", "LicenseResult", "MRZDetectorResult", "MRZPositionResult", "MRZTestQualityResult", "RFIDGraphicsInfoResult", "RFIDTextDataResult", "StatusResult", "TextDataResult", "TextResult"]

class ContainerListListInner(BaseModel):
    """
    ContainerListListInner
    """
    # data type: StatusResult
    oneof_schema_1_validator: Optional[StatusResult] = None
    # data type: TextResult
    oneof_schema_2_validator: Optional[TextResult] = None
    # data type: DocumentImageResult
    oneof_schema_3_validator: Optional[DocumentImageResult] = None
    # data type: ImagesResult
    oneof_schema_4_validator: Optional[ImagesResult] = None
    # data type: ChosenDocumentTypeResult
    oneof_schema_5_validator: Optional[ChosenDocumentTypeResult] = None
    # data type: DocumentTypesCandidatesResult
    oneof_schema_6_validator: Optional[DocumentTypesCandidatesResult] = None
    # data type: TextDataResult
    oneof_schema_7_validator: Optional[TextDataResult] = None
    # data type: GraphicsResult
    oneof_schema_8_validator: Optional[GraphicsResult] = None
    # data type: LexicalAnalysisResult
    oneof_schema_9_validator: Optional[LexicalAnalysisResult] = None
    # data type: AuthenticityResult
    oneof_schema_10_validator: Optional[AuthenticityResult] = None
    # data type: ImageQualityResult
    oneof_schema_11_validator: Optional[ImageQualityResult] = None
    # data type: DocumentPositionResult
    oneof_schema_12_validator: Optional[DocumentPositionResult] = None
    # data type: DocBarCodeInfo
    oneof_schema_13_validator: Optional[DocBarCodeInfo] = None
    # data type: LicenseResult
    oneof_schema_14_validator: Optional[LicenseResult] = None
    # data type: EncryptedRCLResult
    oneof_schema_15_validator: Optional[EncryptedRCLResult] = None
    # data type: DocumentBinaryInfoResult
    oneof_schema_16_validator: Optional[DocumentBinaryInfoResult] = None
    # data type: ByteArrayResult
    oneof_schema_17_validator: Optional[ByteArrayResult] = None
    # data type: FaceDetectionResult
    oneof_schema_18_validator: Optional[FaceDetectionResult] = None
    # data type: MRZDetectorResult
    oneof_schema_19_validator: Optional[MRZDetectorResult] = None
    # data type: MRZPositionResult
    oneof_schema_20_validator: Optional[MRZPositionResult] = None
    # data type: MRZTestQualityResult
    oneof_schema_21_validator: Optional[MRZTestQualityResult] = None
    # data type: RFIDGraphicsInfoResult
    oneof_schema_22_validator: Optional[RFIDGraphicsInfoResult] = None
    # data type: RFIDTextDataResult
    oneof_schema_23_validator: Optional[RFIDTextDataResult] = None
    actual_instance: Optional[Union[AuthenticityResult, ByteArrayResult, ChosenDocumentTypeResult, DocBarCodeInfo, DocumentBinaryInfoResult, DocumentImageResult, DocumentPositionResult, DocumentTypesCandidatesResult, EncryptedRCLResult, FaceDetectionResult, GraphicsResult, ImageQualityResult, ImagesResult, LexicalAnalysisResult, LicenseResult, MRZDetectorResult, MRZPositionResult, MRZTestQualityResult, RFIDGraphicsInfoResult, RFIDTextDataResult, StatusResult, TextDataResult, TextResult]] = None
    one_of_schemas: Set[str] = { "AuthenticityResult", "ByteArrayResult", "ChosenDocumentTypeResult", "DocBarCodeInfo", "DocumentBinaryInfoResult", "DocumentImageResult", "DocumentPositionResult", "DocumentTypesCandidatesResult", "EncryptedRCLResult", "FaceDetectionResult", "GraphicsResult", "ImageQualityResult", "ImagesResult", "LexicalAnalysisResult", "LicenseResult", "MRZDetectorResult", "MRZPositionResult", "MRZTestQualityResult", "RFIDGraphicsInfoResult", "RFIDTextDataResult", "StatusResult", "TextDataResult", "TextResult" }

    model_config = ConfigDict(
        validate_assignment=True,
        protected_namespaces=(),
    )


    discriminator_value_class_map: Dict[str, str] = {
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        instance = ContainerListListInner.model_construct()
        error_messages = []
        match = 0
        # validate data type: StatusResult
        if not isinstance(v, StatusResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `StatusResult`")
        else:
            match += 1
        # validate data type: TextResult
        if not isinstance(v, TextResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `TextResult`")
        else:
            match += 1
        # validate data type: DocumentImageResult
        if not isinstance(v, DocumentImageResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `DocumentImageResult`")
        else:
            match += 1
        # validate data type: ImagesResult
        if not isinstance(v, ImagesResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ImagesResult`")
        else:
            match += 1
        # validate data type: ChosenDocumentTypeResult
        if not isinstance(v, ChosenDocumentTypeResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ChosenDocumentTypeResult`")
        else:
            match += 1
        # validate data type: DocumentTypesCandidatesResult
        if not isinstance(v, DocumentTypesCandidatesResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `DocumentTypesCandidatesResult`")
        else:
            match += 1
        # validate data type: TextDataResult
        if not isinstance(v, TextDataResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `TextDataResult`")
        else:
            match += 1
        # validate data type: GraphicsResult
        if not isinstance(v, GraphicsResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `GraphicsResult`")
        else:
            match += 1
        # validate data type: LexicalAnalysisResult
        if not isinstance(v, LexicalAnalysisResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `LexicalAnalysisResult`")
        else:
            match += 1
        # validate data type: AuthenticityResult
        if not isinstance(v, AuthenticityResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AuthenticityResult`")
        else:
            match += 1
        # validate data type: ImageQualityResult
        if not isinstance(v, ImageQualityResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ImageQualityResult`")
        else:
            match += 1
        # validate data type: DocumentPositionResult
        if not isinstance(v, DocumentPositionResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `DocumentPositionResult`")
        else:
            match += 1
        # validate data type: DocBarCodeInfo
        if not isinstance(v, DocBarCodeInfo):
            error_messages.append(f"Error! Input type `{type(v)}` is not `DocBarCodeInfo`")
        else:
            match += 1
        # validate data type: LicenseResult
        if not isinstance(v, LicenseResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `LicenseResult`")
        else:
            match += 1
        # validate data type: EncryptedRCLResult
        if not isinstance(v, EncryptedRCLResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `EncryptedRCLResult`")
        else:
            match += 1
        # validate data type: DocumentBinaryInfoResult
        if not isinstance(v, DocumentBinaryInfoResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `DocumentBinaryInfoResult`")
        else:
            match += 1
        # validate data type: ByteArrayResult
        if not isinstance(v, ByteArrayResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ByteArrayResult`")
        else:
            match += 1
        # validate data type: FaceDetectionResult
        if not isinstance(v, FaceDetectionResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `FaceDetectionResult`")
        else:
            match += 1
        # validate data type: MRZDetectorResult
        if not isinstance(v, MRZDetectorResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `MRZDetectorResult`")
        else:
            match += 1
        # validate data type: MRZPositionResult
        if not isinstance(v, MRZPositionResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `MRZPositionResult`")
        else:
            match += 1
        # validate data type: MRZTestQualityResult
        if not isinstance(v, MRZTestQualityResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `MRZTestQualityResult`")
        else:
            match += 1
        # validate data type: RFIDGraphicsInfoResult
        if not isinstance(v, RFIDGraphicsInfoResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `RFIDGraphicsInfoResult`")
        else:
            match += 1
        # validate data type: RFIDTextDataResult
        if not isinstance(v, RFIDTextDataResult):
            error_messages.append(f"Error! Input type `{type(v)}` is not `RFIDTextDataResult`")
        else:
            match += 1
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting `actual_instance` in ContainerListListInner with oneOf schemas: AuthenticityResult, ByteArrayResult, ChosenDocumentTypeResult, DocBarCodeInfo, DocumentBinaryInfoResult, DocumentImageResult, DocumentPositionResult, DocumentTypesCandidatesResult, EncryptedRCLResult, FaceDetectionResult, GraphicsResult, ImageQualityResult, ImagesResult, LexicalAnalysisResult, LicenseResult, MRZDetectorResult, MRZPositionResult, MRZTestQualityResult, RFIDGraphicsInfoResult, RFIDTextDataResult, StatusResult, TextDataResult, TextResult. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting `actual_instance` in ContainerListListInner with oneOf schemas: AuthenticityResult, ByteArrayResult, ChosenDocumentTypeResult, DocBarCodeInfo, DocumentBinaryInfoResult, DocumentImageResult, DocumentPositionResult, DocumentTypesCandidatesResult, EncryptedRCLResult, FaceDetectionResult, GraphicsResult, ImageQualityResult, ImagesResult, LexicalAnalysisResult, LicenseResult, MRZDetectorResult, MRZPositionResult, MRZTestQualityResult, RFIDGraphicsInfoResult, RFIDTextDataResult, StatusResult, TextDataResult, TextResult. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: Union[str, Dict[str, Any]]) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        match = 0

        # deserialize data into StatusResult
        try:
            instance.actual_instance = StatusResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into TextResult
        try:
            instance.actual_instance = TextResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into DocumentImageResult
        try:
            instance.actual_instance = DocumentImageResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ImagesResult
        try:
            instance.actual_instance = ImagesResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ChosenDocumentTypeResult
        try:
            instance.actual_instance = ChosenDocumentTypeResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into DocumentTypesCandidatesResult
        try:
            instance.actual_instance = DocumentTypesCandidatesResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into TextDataResult
        try:
            instance.actual_instance = TextDataResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into GraphicsResult
        try:
            instance.actual_instance = GraphicsResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into LexicalAnalysisResult
        try:
            instance.actual_instance = LexicalAnalysisResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into AuthenticityResult
        try:
            instance.actual_instance = AuthenticityResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ImageQualityResult
        try:
            instance.actual_instance = ImageQualityResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into DocumentPositionResult
        try:
            instance.actual_instance = DocumentPositionResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into DocBarCodeInfo
        try:
            instance.actual_instance = DocBarCodeInfo.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into LicenseResult
        try:
            instance.actual_instance = LicenseResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into EncryptedRCLResult
        try:
            instance.actual_instance = EncryptedRCLResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into DocumentBinaryInfoResult
        try:
            instance.actual_instance = DocumentBinaryInfoResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ByteArrayResult
        try:
            instance.actual_instance = ByteArrayResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into FaceDetectionResult
        try:
            instance.actual_instance = FaceDetectionResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into MRZDetectorResult
        try:
            instance.actual_instance = MRZDetectorResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into MRZPositionResult
        try:
            instance.actual_instance = MRZPositionResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into MRZTestQualityResult
        try:
            instance.actual_instance = MRZTestQualityResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into RFIDGraphicsInfoResult
        try:
            instance.actual_instance = RFIDGraphicsInfoResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into RFIDTextDataResult
        try:
            instance.actual_instance = RFIDTextDataResult.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into ContainerListListInner with oneOf schemas: AuthenticityResult, ByteArrayResult, ChosenDocumentTypeResult, DocBarCodeInfo, DocumentBinaryInfoResult, DocumentImageResult, DocumentPositionResult, DocumentTypesCandidatesResult, EncryptedRCLResult, FaceDetectionResult, GraphicsResult, ImageQualityResult, ImagesResult, LexicalAnalysisResult, LicenseResult, MRZDetectorResult, MRZPositionResult, MRZTestQualityResult, RFIDGraphicsInfoResult, RFIDTextDataResult, StatusResult, TextDataResult, TextResult. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into ContainerListListInner with oneOf schemas: AuthenticityResult, ByteArrayResult, ChosenDocumentTypeResult, DocBarCodeInfo, DocumentBinaryInfoResult, DocumentImageResult, DocumentPositionResult, DocumentTypesCandidatesResult, EncryptedRCLResult, FaceDetectionResult, GraphicsResult, ImageQualityResult, ImagesResult, LexicalAnalysisResult, LicenseResult, MRZDetectorResult, MRZPositionResult, MRZTestQualityResult, RFIDGraphicsInfoResult, RFIDTextDataResult, StatusResult, TextDataResult, TextResult. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        if hasattr(self.actual_instance, "to_json") and callable(self.actual_instance.to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Optional[Union[Dict[str, Any], AuthenticityResult, ByteArrayResult, ChosenDocumentTypeResult, DocBarCodeInfo, DocumentBinaryInfoResult, DocumentImageResult, DocumentPositionResult, DocumentTypesCandidatesResult, EncryptedRCLResult, FaceDetectionResult, GraphicsResult, ImageQualityResult, ImagesResult, LexicalAnalysisResult, LicenseResult, MRZDetectorResult, MRZPositionResult, MRZTestQualityResult, RFIDGraphicsInfoResult, RFIDTextDataResult, StatusResult, TextDataResult, TextResult]]:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        if hasattr(self.actual_instance, "to_dict") and callable(self.actual_instance.to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())


